# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'layerPaintUI.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.
from PyQt5.QtGui import QPixmap
from PyQt5.QtWidgets import QApplication, QFileDialog, QTableWidgetItem, QColorDialog, QMessageBox, QDialog, QLabel
from PyQt5.Qt import QThread,QMutex,pyqtSignal
import time
from PyQt5 import QtCore, QtWidgets,QtGui


from layerPaint.LMYUntils.myStringUtil import getImgUrl
from layerPaint.View.layerPaintUI import Ui_MainWindow
import sys
import pandas as pd
from layerPaint.LMYUntils import myStringUtil,myArangeUtil
import matplotlib.pyplot as plt
import numpy as np
import os
from layerPaint.Controller.previewDialogController import previewDialog
from layerPaint.Controller import previewDialogController

dataDictList:list = []
dataDictKey:list = []
figList:list = []
pd.set_option('display.max_columns', None)   #显示完整的列
pd.set_option('display.max_rows', None)  #显示完整的行
class window(QtWidgets.QMainWindow,Ui_MainWindow):
    def __init__(self):
        super().__init__()
        self.setupUi(self)
        self.lineColorPushButton.clicked.connect(self.lineColorPushButtonClicked)
        self.selectFileButton.clicked.connect(self.getFileOnClicked)
        self.selectFileButton.clicked.connect(self.loadBaseData)
        self.previewPushButton.clicked.connect(self.previewButtonClicked)
        self.savePushButton.clicked.connect(self.savePushButtonClicked)
        self.XComboBox.activated[str].connect(self.XComboBoxValueChanged)
        self.YComboBox.activated[str].connect(self.YComboBoxValueChanged)


        # np数组生成的图
        #len_x = show_image.shape[1]  # 获取图像大小
        #wid_y = show_image.shape[0]
        #frame = QImage(show_image.data, len_x, wid_y, len_x * 3, QImage.Format_RGB888)  # 此处如果不加len_x*3，就会发生倾斜
        #pix = QPixmap.fromImage(frame)

    def getFileOnClicked(self):
        self.selectFileButton.setEnabled(False)
        self.thread_2 = Thread_2()
        self.thread_2._signal.connect(self.setSelectFileButtonEnable)
        self.thread_2.start()
        fileName, fileType = QFileDialog.getOpenFileName(self,
                                                         "打开表格",
                                                         "",
                                                         "*.xlsx;*.xls;;All Files(*)")
        global path_openfile_name

        ###获取路径====================================================================
        if fileName == '':
            print('111111')
            path_openfile_name = ''
            pass
        else:
            path_openfile_name = fileName

    def loadBaseData(self):
        global dataDictKey
        global path_openfile_name
        global dataDictList
        dataDictList.clear()
        dataDictKey.clear()
        self.XComboBox.clear()
        self.YComboBox.clear()
        # self.XComboBox.addItem('x轴')
        # self.YComboBox.addItem('y轴')
        ###===========读取表格，转换表格，===========================================
        if  path_openfile_name != '':
            input_table = pd.read_excel(path_openfile_name)
            # print(input_table)
            input_table_rows = input_table.shape[0]
            input_table_colunms = input_table.shape[1]
            dataDictKey = input_table.columns.values.tolist()
            print(dataDictKey)
            #表头
            input_table_header = input_table.columns.values.tolist()

            ###===========读取表格，转换表格，============================================

            ###======================给tablewidget设置行列表头============================
            self.dataTableWidget.setColumnCount(input_table_colunms)
            self.dataTableWidget.setRowCount(input_table_rows)
            self.dataTableWidget.setHorizontalHeaderLabels(input_table_header)
            ###================遍历表格每个元素，同时添加到tablewidget中========================
            for i in range(input_table_rows):
                input_table_rows_values = input_table.iloc[[i]]
               # print(input_table_rows_values)
                input_table_rows_values_array = np.array(input_table_rows_values)
                input_table_rows_values_list = input_table_rows_values_array.tolist()[0]
                #print(input_table_rows_values_list)
                for j in range(input_table_colunms):
                    input_table_items_list = input_table_rows_values_list[j]

                    ###==============将遍历的元素添加到tablewidget中并显示=======================

                    input_table_items = str(input_table_items_list)
                    newItem = QTableWidgetItem(input_table_items)
                    newItem.setTextAlignment(4 | 128)
                    self.dataTableWidget.setItem(i, j, newItem)

                    ###================遍历表格每个元素，同时添加到tablewidget中========================

                    # 刷新界面命令：
            #self.XComboBox.addItems(['1', '2', '3'])

            self.XComboBox.addItems(myStringUtil.deleteBlankStringWithList(input_table_header))
            self.YComboBox.addItems(myStringUtil.deleteBlankStringWithList(input_table_header))
            #计算出建议的最大x、y分别的最大值，最小值和步长
            if 0 < len(dataDictKey):
                self.getDataFromTableWidget()
                print(dataDictList[self.XComboBox.currentIndex()])
                print(dataDictList[self.YComboBox.currentIndex()])
                print(self.lineColorPushButton.text())
                if self.lineColorPushButton.text() == '连线颜色':
                    self.lineColorPushButton.setText('#000000')
                    self.lineColorPushButton.setStyleSheet('QWidget {background-color:#000000}')
                print(self.XComboBox.currentIndex())
                # 处理当未选择X轴或Y轴时默认的预览图
                xDictList = [self.XComboBox.currentText()]
                yDictList = [self.YComboBox.currentText()]
                for i in dataDictKey:
                    xDictList.append(i)
                    yDictList.append(i)
            xArray = dataDictList[self.XComboBox.currentIndex()]
            yArray = dataDictList[self.YComboBox.currentIndex()]
            xFloatArray = []
            yFloatArray = []
            for n in xArray:
                xFloatArray.append(float(n))
            for m in yArray:
                yFloatArray.append(float(m))
            xMax = float(max(xFloatArray))
            xMin = float(min(xFloatArray))
            yMax = float(max(yFloatArray))
            yMin = float(min(yFloatArray))
            print(str(xMax)+'!!!!!!!!!!!!!!!!!!')
            print(str(yMax)+'~~~~~~~~~~~~~~~~~~')
            xStep = myArangeUtil.caculateUnitStep(xMax, xMin)
            yStep = myArangeUtil.caculateUnitStep(yMax, yMin)
            self.MaxXLineEdit.setText(str(xMax))
            self.MinXLineEdit.setText(str(xMin))
            self.XStepLineEdit.setText(str(xStep))
            self.MaxYLineEdit.setText(str(yMax))
            self.MinYLineEdit.setText(str(yMin))
            self.YStepLineEdit.setText(str(yStep))
            # self.XComboBox.adjustSize()
            # self.YComboBox.adjustSize()

            #图片名称
            #self.pictureNameLineEdit.setText()
            QApplication.processEvents()


        else:
            if len(dataDictKey) > 0:
                QMessageBox.information(MainWindow,
                                        '提示！！', '你已取消更新数据源！！')
            else:
                QMessageBox.information(MainWindow,
                                        '提示！！', '你已取消导入数据源！！')




        # qApp = QApplication.instance()
        # qApp.quit()

    # def eventFilter(self, obj, event):
    #
    #     AllItems = [self.combo.itemText(i) for i in range(self.combo.count())]
    #     if obj == self.combo:
    #         if event.type() == QEvent.FocusOut:
    #             if self.combo.lineEdit().text() not in AllItems and self.combo.lineEdit().text() != '':
    #                 self.combo.addItems(self.combo.lineEdit().text());
    #     return QWidget.eventFilter(self, obj, event)

    def lineColorPushButtonClicked(self):
        self.thread_5 = Thread_5()
        self.thread_5.start()
        self.showDialog()
        pass

    def previewButtonClicked(self):
       global dataDictList
       global dataDictKey

       self.thread_3 = Thread_3()
       self.thread_3._reloadUISignal.connect(self.setPreviewButtonEnable)
       self.thread_3.start()

       if(len(dataDictList)>0):
           screenDesktop = QApplication.desktop()
           screenRect = screenDesktop.screenGeometry()
           screenHeight = int(screenRect.height())
           screenWidth = int(screenRect.width())

           if self.widthLineEdit.text() == '' or self.heightLineEdit.text() =='' or self.dpitLineEdit.text() =='':
               QMessageBox.information(self.previewPushButton,
                                       '警告!!!', '宽度、高度和dpi不能为空值!!!')
           elif not (myStringUtil.isNumber(self.widthLineEdit.text())
                   and myStringUtil.isNumber(self.heightLineEdit.text())
                   and myStringUtil.isNumber(self.dpitLineEdit.text())):
               QMessageBox.information(self.previewPushButton,
                                       '警告!!!','请输入数字！！')
           elif int(self.widthLineEdit.text()) > screenWidth +1000:
               QMessageBox.information(self.previewPushButton,
                                       '警告!!!',
                                       ('图片宽度不可以大于屏幕宽度！！！\n提示当前屏幕为%d*%d！！！')%(screenWidth,screenHeight))
           elif int(self.heightLineEdit.text()) > screenHeight+1000:
               QMessageBox.information(self.previewPushButton,
                                       '警告!!!',
                                       ('图片宽度不可以大于屏幕高度！！！\n提示当前屏幕为%d*%d！！！')%(screenWidth,screenHeight))
           elif int(self.dpitLineEdit.text()) <10:
               QMessageBox.information(self.previewPushButton,
                                       '警告!!!','dpi至少大于10!!!')
           else:
               print(dataDictList)
               xNoNoneArray,yNoNoneArray = handlerUnlegalData(dataDictList[self.XComboBox.currentIndex()],
                                  dataDictList[self.YComboBox.currentIndex()])
               xMax = float(max(xNoNoneArray))
               xMin = float(min(xNoNoneArray))
               yMax = float(max(yNoNoneArray))
               yMin = float(min(yNoNoneArray))

               print(xMax)
               print(yMax)

               drawPlotWithParameterInGui(xNoNoneArray,
                                          myStringUtil.superscriptNumberWithString(self.XTitleTextEdit.toPlainText()),
                                          float(self.MaxXLineEdit.text()),
                                          float(self.MinXLineEdit.text()),
                                          float(self.XStepLineEdit.text()),
                                          yNoNoneArray,
                                          myStringUtil.superscriptNumberWithString(self.YTitleTextEdit.toPlainText()),
                                          float(self.MaxYLineEdit.text()),
                                          float(self.MinYLineEdit.text()),
                                          float(self.YStepLineEdit.text()),
                                          self.currentLineStyle(self.lineTypeComboBox.currentIndex()),
                                          self.lineWidthDoubleSpinBox.text(),
                                          str(self.lineColorPushButton.text()),
                                          self.widthLineEdit.text(),
                                          self.heightLineEdit.text(),
                                          self.dpitLineEdit.text())
               # 从本地读图
               pixmap = QPixmap(os.getcwd() + '\\preview.png')  # 按指定路径找到图片
               print(pixmap.size())
               if pixmap:
                 print('!!!!!!!!!!')

               else:
                   pass

               previewDialogController.previewDialog = previewDialog()
               previewDialogController.previewDialog.resizeDialog(pixmap.size().width(), pixmap.size().height())
               previewDialogController.previewDialog.setPreviewImg(pixmap)
               previewDialogController.previewDialog.show()

       else:
           QMessageBox.information(MainWindow,'警告！！', '请先导入数据源！！')

    def savePushButtonClicked(self):
        self.thread_4 = Thread_4()
        self.thread_4._savePictureSignal.connect(self.setSaveButtonEnable)
        self.thread_4.start()
        self.savePicture()

    def XComboBoxValueChanged(self):
        print('X轴改变了！！！')

    def YComboBoxValueChanged(self):
        print('Y轴改变了！！！')

    def showDialog(self):
        col = QColorDialog.getColor()
        print(col.name(), "\n")
        if col.isValid():
            self.lineColorPushButton.setStyleSheet('QWidget {background-color:%s}' % col.name())
            self.lineColorPushButton.setText(col.name())

    def currentLineStyle(self,currentIndex:int)->str:
        # 'solid'(默认) '-' 实线
        # 'dotted' ':' 点虚线
        # 'dashed' '--' 破折线
        # 'dashdot' '-.' 点划线
        # 'None' '' 或 ' ' 不画线
        if currentIndex == 0:
            return 'None'
        elif currentIndex == 1:
            return 'solid'
        elif currentIndex == 2:
            return 'dotted'
        elif currentIndex == 3:
            return 'dashed'
        elif currentIndex == 4:
            return 'dashdot'
        elif currentIndex == 5:
            return 'None'
        else:
            return 'solid'

    def getDataFromTableWidget(self):
        global dataDictKey
        global dataDictList
        # dataDictList.append([0,1,2])
        rowCount = self.dataTableWidget.rowCount()
        columnCount = self.dataTableWidget.columnCount()
        #print(self.dataTableWidget_2.item(0,0).text())
        #print(dataDictKey)
        print()
        i = 0
        while i < columnCount:
            columnDataList = []
            j = 0
            while j < rowCount:
                columnDataList.append(self.dataTableWidget.item(j, i).text())
                j = j + 1
            dataDictList.append(columnDataList)
            #print(dataDictList)
            i= i+1

        #
        # for i in columnCount:
        #     for j in rowCount:
        #        columnDataList = columnDataList.append(self.dataTableWidget_2.item(j,i))
        #     dataDictList = dataDictList.append({i:columnDataList})
        print(dataDictList)

    def setSelectFileButtonEnable(self):
        self.selectFileButton.setEnabled(True)

    def setLineColorPushButtonEnable(self):
        self.lineColorPushButton.setEnabled(True)

    def setPreviewButtonEnable(self):
        self.previewPushButton.setEnabled(True)

    def setSaveButtonEnable(self):
        self.savePushButton.setEnabled(True)

    def showPreviewView(self):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(845, 536)
        MainWindow.setStyleSheet("")
        MainWindow.setAnimated(True)

    def savePicture(self):
        global figList
        if len(figList) > 0:
            fig = figList[0]
            fdir, ftype = QFileDialog.getSaveFileName(self,
                                                      "Save Image",
                                                      "./",
                                                      "Image Files (*.jpg)")
            fig.savefig(fdir, bbox_inches='tight')
            print(fdir)
        else:
            QMessageBox.information(MainWindow,
                                    '警告！！',
                                    '你还未绘制图片！！')


def handlerUnlegalData(xArray:list,
                       yArray:list):
    xNoNoneArray = []
    yNoNoneArray = []
    # xArray = [round(float(i)) for i in xArray]
    print(xArray)
    for i in xArray:
        try:
            xNoNoneArray.append(round(float(i)))
        except:
            print('x轴存在无法转换为数字的项目！！！')
            xNoNoneArray.append(0.0)
        else:
            print('当前转化成功！！！')
        finally:
            print('全部转化成功！！！')
    for n in yArray:
        try:
            yNoNoneArray.append(round(float(n)))
        except:
            yNoNoneArray.append(0.0)
            print('由于参数为非数字已强制转为0.0')
        else:
            print('当前转化成功！！！')
        finally:
            print('全部转化成功！！！')
    return xNoNoneArray,yNoNoneArray


def drawPlotWithParameterInGui(xArray:list,
                               xTitle:str,
                               xMax:float,
                               xMin:float,
                               xStep:float,
                               yArray:list,
                               yTitle:str,
                               yMax:float,
                               yMin:float,
                               yStep:float,
                               lineStyle:str,
                               lineWidth:str,
                               lineColor:str,
                               picWidth:str,
                               picHeight:str,
                               picDPI:str):
    global figLi

    figList.clear()
    #plt.figure(figsize=(float(picWidth)/float(picDPI), float(picHeight)/float(picDPI)), dpi=float(picDPI))
    #plt.figure(dpi=float(picDPI))
    plt.figure(figsize=(int(float(picWidth)/float(picDPI)),
                        int(float(picHeight)/float(picDPI))),
               dpi=int(picDPI))

    plt.rcParams['font.sans-serif'] = ['SimHei']
    plt.rcParams['axes.unicode_minus'] = False


    x = np.array(xArray)
    y = np.array(yArray)

    plt.subplot(1,1,1)
    plt.plot(x,
             y,
             color=lineColor,
             linewidth = lineWidth,
             linestyle = lineStyle)

    plt.xticks(np.arange(0,
                         (xMax + myArangeUtil.caculateUnitStep(xMax, xMin)),
                         step=xStep),
               np.arange(0, (xMax + myArangeUtil.caculateUnitStep(xMax, xMin)),
                         step=xStep))
    #plt.yticks(np.linspace(0,maxY,yUnitNum))
    plt.yticks(np.arange(0,
                         (yMax + myArangeUtil.caculateUnitStep(yMax,yMin)),
                         step=yStep),
               np.arange(0,
                         (yMax + myArangeUtil.caculateUnitStep(yMax,yMin)),
                         step=yStep))
    #plt.xticks(rotation = '90')
    #plt.yticks(rotation='90')
    print(xTitle)
    print(yTitle)
    plt.xlabel(xlabel=xTitle)
    plt.ylabel(ylabel=yTitle)
    ax = plt.gca()
    ax.set_ylim(0)
    ax.set_xlim(0)
    ax.spines['top'].set_visible(False)
    ax.spines['right'].set_visible(False)
    #ax.spines['bottom'].set_visible(False)
    ax.xaxis.set_ticks_position('bottom')
    ax.yaxis.set_ticks_position('left')  # 将y轴的位置设置在右左边
    #ax.invert_yaxis()  # y轴反向
    #ax.invert_xaxis()
    #plt.suptitle("RUNOOB subplot Test")
    fig = plt.gcf()
    figList.append(fig)

    plt.savefig(os.getcwd()+'\\'+'preview.png')
    #plt.scatter([-y for y in yArray], xArray)
    plt.show()



qmut_1 = QMutex() # 创建线程锁
qmut_2 = QMutex()
# 继承QThread
class Thread_1(QThread):  # 线程1
    def __init__(self):
        super().__init__()

    def run(self):
        qmut_1.lock() # 加锁
        values = [1, 2, 3, 4, 5]
        for i in values:
            print(i)
            time.sleep(0.5)  # 休眠
        qmut_1.unlock() # 解锁


class Thread_2(QThread):  # 线程2
    _signal =pyqtSignal()
    def __init__(self):
        super().__init__()

    def run(self):
        # qmut_2.lock()  # 加锁
        values = ["a", "b", "c", "d", "e"]
        for i in values:
            print(i)
            time.sleep(0.5)
        # qmut_2.unlock()  # 解锁
        self._signal.emit()

class Thread_3(QThread):  # 线程2
    _reloadUISignal =pyqtSignal()
    def __init__(self):
        super().__init__()

    def run(self):
        # qmut_2.lock()  # 加锁
        values = ["a", "b", "c", "d", "e"]
        for i in values:
            print(i)
            time.sleep(0.5)
        # qmut_2.unlock()  # 解锁
        self._reloadUISignal.emit()


class Thread_4(QThread):  # 线程2
    _savePictureSignal =pyqtSignal()
    def __init__(self):
        super().__init__()

    def run(self):
        # qmut_2.lock()  # 加锁
        values = ["a", "b", "c", "d", "e"]
        for i in values:
            print(i)
            time.sleep(0.5)
        # qmut_2.unlock()  # 解锁
        self._savePictureSignal.emit()



class Thread_5(QThread):  # 线程2
    _selectColorSignal =pyqtSignal()
    def __init__(self):
        super().__init__()

    def run(self):
        # qmut_2.lock()  # 加锁
        values = ["a", "b", "c", "d", "e"]
        for i in values:
            print(i)
            time.sleep(0.5)
        # qmut_2.unlock()  # 解锁
        self._selectColorSignal.emit()

#---------------------------------------------------------------------------------

if __name__ == '__main__':
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = window()  # 创建窗体对象
    MainWindow.show()  # 显示窗体
    sys.exit(app.exec_())  # 程序关闭时退出进程

